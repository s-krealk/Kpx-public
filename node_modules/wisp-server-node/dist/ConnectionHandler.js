"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.routeRequest = routeRequest;
const ws_1 = __importStar(require("ws"));
const node_net_1 = __importDefault(require("node:net"));
const promises_1 = __importDefault(require("node:dns/promises"));
const node_dgram_1 = __importDefault(require("node:dgram"));
const Packets_js_1 = __importDefault(require("./Packets.js"));
const Types_js_1 = require("./Types.js");
const Logger_js_1 = require("./utils/Logger.js");
const wsproxy_js_1 = require("./wsproxy.js");
const Error_js_1 = require("./utils/Error.js");
const wss = new ws_1.WebSocketServer({ noServer: true });
const defaultOptions = { logLevel: Types_js_1.LOG_LEVEL.INFO, pingInterval: 30 };
function routeRequest(wsOrIncomingMessage_1, socket_1, head_1) {
    return __awaiter(this, arguments, void 0, function* (wsOrIncomingMessage, socket, head, options = defaultOptions) {
        options = Object.assign({}, defaultOptions, options);
        if (!(wsOrIncomingMessage instanceof ws_1.default) && socket && head) {
            wss.handleUpgrade(wsOrIncomingMessage, socket, head, (ws) => {
                var _a;
                if (!((_a = wsOrIncomingMessage.url) === null || _a === void 0 ? void 0 : _a.endsWith("/"))) {
                    (0, wsproxy_js_1.handleWsProxy)(ws, wsOrIncomingMessage.url);
                    return;
                }
                routeRequest(ws, undefined, undefined, options);
            });
            return;
        }
        if (!(wsOrIncomingMessage instanceof ws_1.default))
            return;
        const ws = wsOrIncomingMessage;
        const connections = new Map();
        const logger = new Logger_js_1.Logger(options.logLevel);
        const pingInterval = setInterval(() => {
            logger.debug(`sending websocket ping`);
            ws.ping();
        }, options.pingInterval * 1000);
        ws.on("message", (data) => __awaiter(this, void 0, void 0, function* () {
            try {
                if (!Buffer.isBuffer(data) && !(data instanceof ArrayBuffer)) {
                    logger.error("Invalid WebSocket message data");
                    return;
                }
                const wispFrame = Packets_js_1.default.wispFrameParser(Buffer.from(data));
                if (wispFrame.type === Types_js_1.PACKET_TYPE.CONNECT) {
                    const connectFrame = Packets_js_1.default.connectPacketParser(wispFrame.payload);
                    if (connectFrame.streamType === Types_js_1.STREAM_TYPE.TCP) {
                        const client = new node_net_1.default.Socket();
                        client.connect(connectFrame.port, connectFrame.hostname);
                        connections.set(wispFrame.streamID, {
                            client: client,
                            buffer: 127,
                        });
                        client.on("data", function (data) {
                            ws.send(Packets_js_1.default.dataPacketMaker(wispFrame, data));
                        });
                        client.on("error", function (err) {
                            logger.error(`An error occured in the connection to ${connectFrame.hostname} (${wispFrame.streamID}) with the message ${err.message}`);
                            ws.send(Packets_js_1.default.closePacketMaker(wispFrame, (0, Error_js_1.checkErrorCode)(err)));
                            connections.delete(wispFrame.streamID);
                        });
                        client.on("close", function () {
                            if (connections.get(wispFrame.streamID)) {
                                ws.send(Packets_js_1.default.closePacketMaker(wispFrame, 0x02));
                                connections.delete(wispFrame.streamID);
                            }
                        });
                    }
                    else if (connectFrame.streamType === Types_js_1.STREAM_TYPE.UDP) {
                        let iplevel = node_net_1.default.isIP(connectFrame.hostname);
                        let host = connectFrame.hostname;
                        if (iplevel === 0) {
                            try {
                                host = (yield promises_1.default.resolve(connectFrame.hostname))[0];
                                iplevel = node_net_1.default.isIP(host);
                            }
                            catch (e) {
                                logger.error("Failure while trying to resolve hostname " +
                                    connectFrame.hostname +
                                    " with error: " +
                                    e);
                                ws.send(Packets_js_1.default.closePacketMaker(wispFrame, 0x42));
                                return;
                            }
                        }
                        if (iplevel !== 4 && iplevel !== 6) {
                            return;
                        }
                        const client = node_dgram_1.default.createSocket(iplevel === 6 ? "udp6" : "udp4");
                        client.connect(connectFrame.port, host);
                        client.connected = false;
                        client.on("connect", () => {
                            client.connected = true;
                        });
                        client.on("message", (data, rinfo) => {
                            ws.send(Packets_js_1.default.dataPacketMaker(wispFrame, data));
                        });
                        client.on("error", (err) => {
                            logger.error(`An error occured in the connection to ${connectFrame.hostname} (${wispFrame.streamID}) with the message ${err.message}`);
                            ws.send(Packets_js_1.default.closePacketMaker(wispFrame, (0, Error_js_1.checkErrorCode)(err)));
                            connections.delete(wispFrame.streamID);
                            client.close();
                        });
                        client.on("close", function () {
                            if (connections.get(wispFrame.streamID)) {
                                ws.send(Packets_js_1.default.closePacketMaker(wispFrame, 0x02));
                                connections.delete(wispFrame.streamID);
                            }
                        });
                        connections.set(wispFrame.streamID, {
                            client,
                        });
                    }
                }
                if (wispFrame.type === Types_js_1.PACKET_TYPE.DATA) {
                    const stream = connections.get(wispFrame.streamID);
                    if (stream && stream.client instanceof node_net_1.default.Socket) {
                        stream.client.write(wispFrame.payload);
                        stream.buffer--;
                        if (stream.buffer === 0) {
                            stream.buffer = 127;
                            ws.send(Packets_js_1.default.continuePacketMaker(wispFrame, stream.buffer));
                        }
                    }
                    else if (stream && stream.client instanceof node_dgram_1.default.Socket) {
                        stream.client.send(wispFrame.payload, undefined, undefined, (err) => {
                            if (err) {
                                ws.send(Packets_js_1.default.closePacketMaker(wispFrame, (0, Error_js_1.checkErrorCode)(err)));
                                if (stream.client.connected) {
                                    stream.client.close();
                                }
                                connections.delete(wispFrame.streamID);
                            }
                        });
                    }
                }
                if (wispFrame.type === Types_js_1.PACKET_TYPE.CLOSE) {
                    logger.log("Client decided to terminate with reason " + new DataView(wispFrame.payload.buffer).getUint8(0));
                    const stream = connections.get(wispFrame.streamID);
                    if (stream && stream.client instanceof node_net_1.default.Socket) {
                        stream.client.destroy();
                    }
                    else if (stream && stream.client instanceof node_dgram_1.default.Socket) {
                        stream.client.close();
                    }
                    connections.delete(wispFrame.streamID);
                }
            }
            catch (e) {
                ws.close();
                logger.error(`WISP incoming message handler error: `, e);
                for (const { client } of connections.values()) {
                    if (client instanceof node_net_1.default.Socket) {
                        client.destroy();
                    }
                    else if (client instanceof node_dgram_1.default.Socket) {
                        client.close();
                    }
                }
                connections.clear();
            }
        }));
        ws.on("close", (code, reason) => {
            logger.debug(`WebSocket connection closed with code ${code} and reason: ${reason}`);
            for (const { client } of connections.values()) {
                if (client instanceof node_net_1.default.Socket) {
                    client.destroy();
                }
                else if (client instanceof node_dgram_1.default.Socket) {
                    client.close();
                }
            }
            connections.clear();
            clearTimeout(pingInterval);
        });
        ws.send(Packets_js_1.default.continuePacketMaker({ streamID: 0 }, 127));
    });
}
exports.default = {
    routeRequest,
};
//# sourceMappingURL=ConnectionHandler.js.map